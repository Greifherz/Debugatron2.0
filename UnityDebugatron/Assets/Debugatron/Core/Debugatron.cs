///***************************************************************
// * 					Debugatron v0.9.4
// * 
// * Author: Douglas Barbará 					OCT-2014 - SEP-2015
// * 
// * Features:
// * 		Debug central - You can turn them off all at the same place
// * 		Colored debug - Easy to color your debug strings
// * 		Debug groups - You can group your debugs in groups and turn them off for better debug view
// * 		Debug Ease - You may send anything to the log function. It is advised however that you override the ToString method on your classes
// * 		Persistence - Debug groups can be created and persisted through Unity3D's own IDE
// * 		Timestamp - Timestamp on all debugs
// *		Dump & AutoDump - Implement the dump of all stored debugs
// * 		External Output - Configure your output, be it in local machine path or send it as a request to a server
// * 
// * Planned Features:
// * 		Custom Timestamp - Start and end time tracking at your will
// * 		Debug Anything - You may let debugatron use reflection so you won't need to override the ToString for everything(not advised though)
// * 		Execution time - Track your code's optimization
// * 		Output Window - Get to see while running the debug messages
// * 		Build Support - With the Output Window you should still see the logs while in a build, although optimized
// * 		Watch Debug - Wire a variable or instruction to print always with a group
// * 
// * Changelog:
// * 		Oct-2014 - Project Start
// * 			* Debug Central
// * 			* Colored Debug
// * 			* Debug Groups
// * 		
// * 		July-2015 
// * 			* Unity Color to HEX, enabling more colors including in versions prior to 5.0
// * 			* Documentation improvement
// * 			* Started Debugatron Settings on Unity3D IDE
// * 			* Flag for not running outside the inspector ( will be improved later )
// * 
// * 		August-2015
// * 			* Interface for adding and removing groups through inspector
// * 			* Added ID to the groups so you don't need to write correct string all the time
// * 			* Added Backward compatibility for common rich text names in colors, such as red or magenta.
// * 			* Sent debugatron settings to the DebugatronSettings in the inspector
// * 			* Made logic of persisting runtime created groups if needed and send to DebugatronSettings
// * 			* Debug Everything
// * 			* Fixed multi-lined debug error that caused the whole debug to lose color
// * 			* Optional Timestamps
// * 			* Fixed issue that prevented building and optimized for build logging
// * 			
// * 		September-2015
// * 			* Customizable Timestamp
// * 			* Dump preparation (Store setting global and for each group) and Outputs
// * 			* Better structure for editor scripts
// * 			* Optional throw error, configured at settings
// * 			* Added planned feature of Watch
// * 			
// * 		April-2017
// * 		    * Added External interface and external ouput handling
// * 		    
// * 
// * 		TODO Near Future
// * 			* Include in the project a preconstructed debug console as external
// * 			* Order dump by datetime despite separate groups (bit of a challenge)
// * 			* Update the example project to include new features
// * 			* Update the logging using Unity's new stuff for logging
// * 			* Search bar on debug group settings
// */
//#if UNITY_EDITOR
//using UnityEditor;
//#endif

//using UnityEngine;
//using System;
//using System.Collections;
//using System.Collections.Generic;
//using System.Linq;

//namespace DebugatronCore
//{
//	public static class Debugatron 
//	{	
//		//Init flag
//		public static bool isInit = false;
		
//		//Main Flag. Public and static for user to turn on and off
//		public static bool AllowDebug = true;
		
//		//Timestamp Start date
//		public static DateTime TimestampStart;

//		//Registered external handlers for strings generated by debugatron
//		public static List<IExternalDebugatronOutputHandler> ExternalHandlers;
		
//		//Dictionary to regulate the allowance of a determined debug group and its configuration to in fact debug
//		private static Dictionary<string,DebugGroup> DebugGroups;
		
//		//Dictionary to regulate the allowance of a determined debug group and its configuration to in fact debug
//		//Uses the ID to lookup.
//		private static Dictionary<int,DebugGroup> DebugGroupsById;
		
//		/// <summary>
//		/// Init Debugatron. Function needs to be called before any debug.
//		/// </summary>
//		public static void Init()
//		{
//			#if UNITY_EDITOR
//				if(!isInit)
//				{
//					LoadSettings();
//					ProcessDebugGroupConfig();
				
//					if(Settings.EnableTimestamp)
//						TimestampStart = System.DateTime.UtcNow;
					
//					isInit = true;
				
//					Log ("Debugatron Init","Default");
					
//					if(Settings.AutoDump)
//					{//Creates a gameobject with a mono to listen to application quit
//						GameObject AutoDumper = new GameObject();
//						AutoDumper.name = "Debugatron Auto-Dumper";
//						AutoDumper.AddComponent<AutoDumper>();
//					}
//				}
//			#endif
//		}
		
//		/// <summary>
//		/// The settings. Needed to create the window on editor time.
//		/// </summary>
//		public static DebugatronSettingsConfig Settings = null;

//		private static bool CheckAutoInit()
//		{
//			if(Settings == null)
//			{
//				DebugatronSettingsConfig Cached = Resources.Load<DebugatronSettingsConfig>("DebugatronSettings");
//				if(Cached == null)
//					return false;
//				else
//					return Cached.AutoInit;
//			}
//			else
//			{
//				return Settings.AutoInit;
//			}
//		}

//		/// <summary>
//		/// Loads the settings into debugatron.
//		/// </summary>	
//		public static DebugatronSettingsConfig LoadSettings()
//		{
//			if(Settings != null)
//				return Settings;
			
//			#if UNITY_EDITOR
//			Settings = AssetDatabase.LoadAssetAtPath("Assets/Debugatron/Resources/DebugatronSettings.asset",typeof(DebugatronSettingsConfig)) as DebugatronSettingsConfig;
//			if (Settings == null) 
//			{
//				Debug.Log("Created new settings asset");
//				Settings = ScriptableObject.CreateInstance<DebugatronSettingsConfig> ();
//				AssetDatabase.CreateAsset (Settings, "Assets/Debugatron/Resources/DebugatronSettings.asset");
//				AssetDatabase.SaveAssets ();
//			}
//			#else
			
//			Settings = Resources.Load<DebugatronSettingsConfig>("DebugatronSettings");
			
//			#endif
//			return Settings;
//		}
		
//		public static DebugGroupConfig GroupSettings = null;
		
//		/// <summary>
//		/// Loads the group settings into debugatron.
//		/// </summary>	
//		public static DebugGroupConfig LoadDebugGroups()
//		{
//			if(GroupSettings != null)
//				return GroupSettings;
			
//			#if UNITY_EDITOR
//			GroupSettings = AssetDatabase.LoadAssetAtPath("Assets/Debugatron/Resources/GroupSettings.asset",typeof(DebugGroupConfig)) as DebugGroupConfig;
//			if (GroupSettings == null) 
//			{
//				GroupSettings = ScriptableObject.CreateInstance<DebugGroupConfig> ();
//				AssetDatabase.CreateAsset (GroupSettings, "Assets/Debugatron/Resources/GroupSettings.asset");
				
//				DebugGroup DefaultGroup;
//				if(Settings != null)
//					DefaultGroup = new DebugGroup("Default",Settings.DefaultGroupTitleColor,Settings.DefaultGroupTextColor);
//				else
//					DefaultGroup = new DebugGroup("Default",Color.white,Color.white);
				
//				CreateDebugGroup(DefaultGroup);
				
//				AssetDatabase.SaveAssets ();
//			}
//			#else
//				GroupSettings = Resources.Load<DebugGroupConfig>("GroupSettings");
//			#endif
//			return GroupSettings;
//		}
		
//		/// <summary>
//		/// Processes the debug group configuration from the DebugGroupSettings.
//		/// </summary>
//		private static void ProcessDebugGroupConfig()
//		{
//			if(GroupSettings == null)
//				GroupSettings = LoadDebugGroups();
			
//			DebugGroups = new Dictionary<string, DebugGroup>();
//			DebugGroupsById = new Dictionary<int, DebugGroup>();
			
//			foreach(DebugGroup Group in GroupSettings.DebugGroups)
//			{
//				CreateDebugGroup(Group);
//			}
//		}
		
//		/// <summary>
//		/// Creates a new debug group.
//		/// </summary>
//		/// <returns>
//		/// The debug group Id.
//		/// </returns>
//		/// <param name='Group'>
//		/// Instantiated Group.
//		/// </param>
//		public static int CreateDebugGroup(DebugGroup Group)
//		{
//			if(!isInit || isInit && Settings.AllowNewGroups)
//			{
//				if(DebugGroups != null && DebugGroupsById != null)
//				{
//					if(DebugGroups.ContainsKey(Group.Name))
//						return -1;
					
//					if(Settings.NewGroupPersistence)
//					{
//						GroupSettings.AddGroup(Group);	
//					}
//					else
//					{
//						Group.Id = DebugGroups.Count + 1;	
//					}
					
//					DebugGroups.Add(Group.Name,Group);
//					DebugGroupsById.Add(Group.Id,Group);
					
//					return Group.Id;
//				}
//			}
//			return -1;
//		}
		
//		/// <summary>
//		/// Creates a new  debug group.
//		/// </summary>
//		/// <returns>
//		/// The debug group Id.
//		/// </returns>
//		/// <param name='Name'>
//		/// Group Name.
//		/// </param>
//		/// <param name='GroupColor'>
//		/// Group color.
//		/// </param>
//		/// <param name='DebugColor'>
//		/// Debug color.
//		/// </param>
//		public static int CreateDebugGroup(string Name, Color GroupColor, Color DebugColor)
//		{
//			if(Validate())
//			{
//				DebugGroup Group = new DebugGroup(Name,GroupColor,DebugColor);	
//				return CreateDebugGroup(Group);
//			}
//			return -1;
//		}
		
//		/// <summary>
//		/// Creates a new  debug group.
//		/// </summary>
//		/// <returns>
//		/// The debug group Id.
//		/// </returns>
//		/// <param name='Name'>
//		/// Group Name.
//		/// </param>
//		/// <param name='GroupColor'>
//		/// Group color.
//		/// </param>
//		/// <param name='DebugColor'>
//		/// Debug color.
//		/// </param>
//		public static int CreateDebugGroup(string Name, string GroupColor = "", string DebugColor = "")
//		{
//			if(Validate())
//			{
//				DebugGroup Group = new DebugGroup(Name,GroupColor,DebugColor);	
//				return CreateDebugGroup(Group);
//			}
//			return -1;
//		}
		
//		/// <summary>
//		/// Validate if allowed to send output.
//		/// </summary>
//		private static bool Validate()
//		{
//			#if UNITY_EDITOR
//				if(!isInit)
//				{
//					if(CheckAutoInit())
//					{
//						Debug.Log("Debugatron Auto-Init");
//						Init();
//					}
//					else
//						Debug.Log("Debugatron not init");
//				}
//				if(Settings == null || (!Settings.DebugAllowed || !AllowDebug) && !Settings.StoreDebug)
//				{
//					return false;	
//				}
//				else if(DebugGroups != null)
//				{
//					return true;
//				}
//				else
//				{
//					throw new Exception("[Debugatron Warning] Init not called");
//				}
//			#else
//				return false;
//			#endif
//		}
		
//		/// <summary>
//		/// Sets the group allowance.
//		/// </summary>
//		/// <param name='DebugGroupName'>
//		/// Debug group name.
//		/// </param>
//		/// <param name='Allowance'>
//		/// Allowance.
//		/// </param>
//		public static void SetGroupAllowance(string DebugGroupName,bool Allowance)
//		{
//			if(Validate())
//			{
//				if(DebugGroups.ContainsKey(DebugGroupName))
//				{
//					DebugGroups[DebugGroupName].Allowed = Allowance;
//				}
//				else
//				{	
//					if(Settings == null || Settings.LogErrorExceptionAllowed)
//						throw new Exception("[Debugatron Warning] The group you tried to change allowance does not exist.");
//				}
//			}
//		}
	
		
//		/// <summary>
//		/// Changes the group color scheme.
//		/// </summary>
//		/// <param name='DebugGroupName'>
//		/// Debug group name.
//		/// </param>
//		/// <param name='GroupColor'>
//		/// Group color. Color of the [Flag]
//		/// Default is White.
//		/// </param>
//		/// <param name='DebugColor'>
//		/// Debug color. Color of the text.
//		/// Default is White.
//		/// </param>
//		public static void ChangeGroupColorScheme(string DebugGroupName,string GroupColor = "", string DebugColor = "")
//		{
//			if(Validate())
//			{
//				if(DebugGroups.ContainsKey(DebugGroupName))
//				{
//					DebugGroup Group = DebugGroups[DebugGroupName];
//					Group.DebugColor = DebugColor.Equals("") ? new Color() : (Color)DebugGroup.HexToColor(DebugColor) ;
//					Group.GroupColor = GroupColor.Equals("") ? new Color() : (Color)DebugGroup.HexToColor(GroupColor) ;
//				}
//				else
//				{
//					if(Settings == null || Settings.LogErrorExceptionAllowed)
//						throw new Exception("[Debugatron Warning] Group you are trying to change the color Scheme does not exist");
//				}
//			}
//		}
		
//		/// <summary>
//		/// Changes the group color scheme.
//		/// </summary>
//		/// <param name='DebugGroupName'>
//		/// Debug group name.
//		/// </param>
//		/// <param name='GroupColor'>
//		/// Group color. Color of the [Flag]
//		/// </param>
//		/// <param name='DebugColor'>
//		/// Debug color. Color of the text.
//		/// </param>
//		public static void ChangeGroupColorScheme(string DebugGroupName,Color GroupColor, Color DebugColor )
//		{
//			if(Validate())
//			{
//				if(DebugGroups.ContainsKey(DebugGroupName))
//				{
//					DebugGroup Group = DebugGroups[DebugGroupName];
//					Group.DebugColor = DebugColor ;
//					Group.GroupColor = GroupColor ;
//				}
//				else
//				{
//					if(Settings == null || Settings.LogErrorExceptionAllowed)
//						throw new Exception("[Debugatron Warning] Group you are trying to change the color Scheme does not exist");
//				}
//			}
//		}
		
//		/// <summary>
//		/// Mutes or Unmutes a group.
//		/// </summary>
//		/// <param name='DebugGroupName'>
//		/// Debug group name.
//		/// </param>
//		/// <param name='Mute'>
//		/// Mute.
//		/// </param>
//		public static void MuteGroup(string DebugGroupName,bool Mute)
//		{
//			if(Validate())
//			{
//				if(DebugGroups.ContainsKey(DebugGroupName))
//				{
//					DebugGroup Group = DebugGroups[DebugGroupName];
//					Group.Allowed = !Mute;
//				}
//				else
//				{
//					if(Settings == null || Settings.LogErrorExceptionAllowed)
//						throw new Exception("[Debugatron Warning] Group you are trying to mute does not exist");
//				}
//			}
//		}
		
//		#region Log Functions
		
//		/// <summary>
//		/// Unified to string. Function created so you may call it to debug a list or array or any object at all
//		/// </summary>
//		/// <returns>
//		/// The string representing the object.
//		/// </returns>
//		/// <param name='Obj'>
//		/// Object.
//		/// </param>
//		public static string UnifiedToString(System.Object Obj)
//		{
//			string Ret = "";
//			if(typeof(IEnumerable).IsAssignableFrom(Obj.GetType()) && !typeof(string).IsAssignableFrom(Obj.GetType()))
//			{
//				try
//				{
//					IEnumerable ListOrArray = (IEnumerable)Obj;
//					int j = 1;
//					foreach(var innerObj in ListOrArray)
//					{
//						Ret += j.ToString() + " - " + UnifiedToString(innerObj) + " \n";
						
//						j++;
//					}
//				}
//				catch
//				{
//					throw new OverflowException("Overflow Exception. Maybe the object you're trying to debug contains cyclic reference");	
//				}
//			}
//			else if (!typeof(string).IsAssignableFrom(Obj.GetType()))
//			{
//				Ret += Obj.ToString();	
//			}
//			else
//				Ret += (string)Obj;
			
//			return Ret;
//		}
		
//		/// <summary>
//		/// Log the specified Pretext, Obj and DebugGroupName.
//		/// </summary>
//		/// <param name='Pretext'>
//		/// Pretext.
//		/// </param>
//		/// <param name='Obj'>
//		/// Object.
//		/// </param>
//		/// <param name='DebugGroupName'>
//		/// Debug group name.
//		/// </param>
//		public static void Log(string Pretext,System.Object Obj,string DebugGroupName = "")
//		{
//			if(Validate())
//			{
//				string str = "";
//				str += Pretext + " \n";
//				str += UnifiedToString(Obj);
				
//				if(DebugGroupName.Equals("") || !DebugGroups.ContainsKey(DebugGroupName))
//				{
//					Log (str,-1);	
//				}
//				else
//				{
//					Log(str,DebugGroupName);
//				}
//			}
//		}
		
//		/// <summary>
//		/// Log the specified Pretext, Obj and DebugGroupId.
//		/// </summary>
//		/// <param name='Pretext'>
//		/// Pretext.
//		/// </param>
//		/// <param name='Obj'>
//		/// Object.
//		/// </param>
//		/// <param name='DebugGroupId'>
//		/// Debug group identifier.
//		/// </param>
//		public static void Log(string Pretext,System.Object Obj,int DebugGroupId)
//		{
//			if(Validate())
//			{
//				string str = "";
//				str += Pretext + " \n";
//				str += UnifiedToString(Obj);
//				Log (str,DebugGroupId);
//			}
//		}
		
//		public static void Log(System.Object Obj,int DebugGroupId)
//		{
//			if(Validate())
//			{
//				string str = "";
//				str += UnifiedToString(Obj);
//				Log (str,DebugGroupId);
//			}
//		}
		
//		public static void Log(System.Object Obj,string DebugGroupName)
//		{
//			if(Validate())
//			{
//				string str = "";
//				str += UnifiedToString(Obj);
//				Log(str,DebugGroupName);
//			}
//		}
		
//		/// <summary>
//		/// Log the specified Text member of DebugGroup.
//		/// If DebugGroup is not registed it will register then call Log again. 
//		/// It will log the new group if AllowNewGroups flag is true.
//		/// </summary>
//		/// <param name='str'>
//		/// What you want to debug
//		/// </param>
//		/// <param name='DebugGroup'>
//		/// Debug group this log is member of
//		/// </param>
//		public static void Log(string str,int DebugGroupId)
//		{
//			if(Validate())
//			{
//				try
//				{
//					if(DebugGroupsById.ContainsKey(DebugGroupId))
//					{
//						DebugGroup Group = DebugGroupsById[DebugGroupId];
											
//						Group.Write(str);
//					}
//					else
//					{
//						str += "\n -- Group not found, using default -- ";
//						DebugGroup Group = DebugGroupsById[0];
						
//						Group.Write(str);
//					}
//				}
//				catch(Exception ex)
//				{
//                    Debug.LogError(ex.Message);
//					return;
//				}
//			}
//		}
		
//		/// <summary>
//		/// Log the specified Text member of DebugGroup.
//		/// If DebugGroup is not registed it will register then call Log again. 
//		/// It will log the new group if AllowNewGroups flag is true.
//		/// </summary>
//		/// <param name='str'>
//		/// What you want to debug
//		/// </param>
//		/// <param name='DebugGroup'>
//		/// Debug group this log is member of
//		/// </param>
//		public static void Log(string str,string DebugGroupName = "Default")
//		{
//			if(Validate())
//			{
//				try
//				{
//					if(DebugGroups.ContainsKey(DebugGroupName))
//					{
//						DebugGroup Group = DebugGroups[DebugGroupName];
						
//						Group.Write(str);
//					}
//					else
//					{
//						DebugGroup Group;
//						if(Settings.AutoCreate)
//						{
//							if(Settings == null)
//								Group = new DebugGroup(DebugGroupName,"","");
//							else
//								Group = new DebugGroup(DebugGroupName,Settings.DefaultGroupTitleColor,Settings.DefaultGroupTextColor);
							
//							CreateDebugGroup(Group);
//							str += "\n -- Group not found, AutoCreate -- ";
//							Log (str,Group.Id);						
//						}
//						else
//						{
//							str += "\n -- Group not found, using default -- ";
//							Log (str,0);
//						}
//					}
//				}
//				catch (Exception ex)
//                {
//                    Debug.LogError(ex.Message);
//                    return;
//				}
//			}
//		}
		
//		#endregion
		
//		#region Dump
		
		
//		/*********************************************************************************
//		 * The dump does not cache in memory the big data that is the group's information on string for 
//		 * better performance. 
//		 * 
//		 * Also, each group handles it's own printing on the file to maintain the unity of responsibility.
//		 ************************************************************************************************/
		
		
//		/// <summary>
//		/// Dumps the Log history of a group as a Log.
//		/// </summary>
//		/// <param name='DebugGroup'>
//		/// Debug group.
//		/// </param>
//		/// <exception cref='Exception'>
//		/// Is thrown when the exception.
//		/// </exception>
//		public static void DumpLogHistory(string GroupName)
//		{
//			if(DebugGroups.ContainsKey(GroupName))
//				DumpLogHistory(DebugGroups[GroupName]);
//			else
//			{
//				if(Settings == null || Settings.LogErrorExceptionAllowed)
//					throw new Exception("[Debugatron Warning] Group you're trying to dump " + GroupName + " does not exist");
//			}
//		}
		
//		/// <summary>
//		/// Dumps the Log history of a group as a Log.
//		/// </summary>
//		/// <param name='DebugGroup'>
//		/// Debug group.
//		/// </param>
//		/// <exception cref='Exception'>
//		/// Is thrown when the exception.
//		/// </exception>
//		public static void DumpLogHistory(int GroupId)
//		{
//			if(DebugGroupsById.ContainsKey(GroupId))
//				DumpLogHistory(DebugGroupsById[GroupId]);
//			else
//			{
//				if(Settings == null || Settings.LogErrorExceptionAllowed)
//					throw new Exception("[Debugatron Warning] Group you're trying to dump ID" + GroupId.ToString() + " does not exist");
//			}
//		}

//        /// <summary>
//        /// Dumps the Log history of a group as a Log.
//        /// </summary>
//        /// <param name='DebugGroup'>
//        /// Debug group.
//        /// </param>
//        /// <exception cref='Exception'>
//        /// Is thrown when the exception.
//        /// </exception>
//        public static void DumpLogHistory(DebugGroup Group)
//		{
//			if(Group == null) return;
			
//			List<string> FilePaths = GetFilePaths(Group.Name + "-");
			
//			for(int i = 0 ; i < FilePaths.Count ; i++)
//			{
//				System.IO.File.Create(FilePaths[i]).Close();;
				
//				using (System.IO.StreamWriter FileWriter = 
//	            	new System.IO.StreamWriter(FilePaths[i], true))
//	        	{
//					FileWriter.WriteLine("**********************************************************************");
//					FileWriter.WriteLine("****************** DEBUGATRON DUMP FILE ******************************");
//					FileWriter.WriteLine("**********************************************************************");
//					FileWriter.WriteLine(DateTime.Today.ToString());
//					FileWriter.WriteLine(Environment.NewLine + Environment.NewLine + Environment.NewLine);
					
//					Group.DumpGroup(FileWriter);
					
//					FileWriter.WriteLine("**********************************************************************");
//					FileWriter.WriteLine("**************** DEBUGATRON DUMP FILE END ****************************");
//					FileWriter.WriteLine("**********************************************************************");
//				}
//			}
			
//			Log(Group.Name + "Group Dump Finished with success");
//		}
//        /// <summary>
//        /// Dumps the entire log history
//        /// </summary>
//        public static void DumpLogHistory()
//		{
//			List<string> FilePaths = GetFilePaths();
			
//			for(int i = 0 ; i < FilePaths.Count ; i++)
//			{
//				System.IO.File.Create(FilePaths[i]).Close();
				
//				using (System.IO.StreamWriter FileWriter = 
//	            	new System.IO.StreamWriter(FilePaths[i], true))
//	        	{
//					FileWriter.WriteLine("**********************************************************************");
//					FileWriter.WriteLine("****************** DEBUGATRON DUMP FILE ******************************");
//					FileWriter.WriteLine("**********************************************************************");
//					FileWriter.WriteLine(DateTime.Today.ToString());
//					FileWriter.WriteLine(Environment.NewLine + Environment.NewLine + Environment.NewLine);
					
//					foreach(var Pair in DebugGroups)
//					{
//						if(Pair.Value == null) continue;
						
//						DebugGroup CurrentGroup = Pair.Value;
						
//						if(CurrentGroup == null) continue;
						
//						CurrentGroup.DumpGroup(FileWriter);
//					}
					
//					FileWriter.WriteLine("**********************************************************************");
//					FileWriter.WriteLine("**************** DEBUGATRON DUMP FILE END ****************************");
//					FileWriter.WriteLine("**********************************************************************");
//				}
//				Log ("Finished Dumping to " + FilePaths[i]);
//			}			
//			Log("Full Dump Finished with success");
//		}		
		
//        /// <summary>
//        /// Gets the paths as checked in the settings to make a log output file.
//        /// </summary>
//        /// <param name="AdditiveFileName"></param>
//        /// <returns></returns>
//		private static List<string> GetFilePaths(string AdditiveFileName = "")
//		{
//			List<string> FilePaths = new List<string>();
			
//			string DebugatronDumpFileName = @"\"+ AdditiveFileName +"DebugatronDump-" +DateTime.UtcNow.Year.ToString() + DateTime.UtcNow.Month.ToString() + DateTime.UtcNow.Day.ToString() + DateTime.UtcNow.Hour.ToString() + DateTime.UtcNow.Minute.ToString() + ".log";  
			
//			if(Settings.OutputToDesktop)
//			{
//				FilePaths.Add(Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + DebugatronDumpFileName);
//			}
//			if(Settings.OutputToPersistentPath)
//			{
//				FilePaths.Add(Application.persistentDataPath + DebugatronDumpFileName);
//			}
//			if(Settings.OutputToProject)
//			{
//				System.IO.Directory.CreateDirectory(Environment.CurrentDirectory + @"\DebugatronDump");
//				FilePaths.Add(Environment.CurrentDirectory + @"\DebugatronDump" + DebugatronDumpFileName);
//			}
//			if(Settings.CustomOutputPath)
//			{
//				if(!System.IO.Directory.Exists(Settings.DumpOutputPath + DebugatronDumpFileName))
//					System.IO.Directory.CreateDirectory(Settings.DumpOutputPath + DebugatronDumpFileName);
				
//				FilePaths.Add(Settings.DumpOutputPath + DebugatronDumpFileName);	
//			}
			
//			return FilePaths;
//		}
	
//		#endregion

//		#region Externals

//        /// <summary>
//        /// Adds an External to debugatron
//        /// </summary>
//        /// <param name="Handler"></param>
//		public static void AddExternalOutput(IExternalDebugatronOutputHandler Handler)
//		{
//			if(ExternalHandlers == null)
//				ExternalHandlers = new List<IExternalDebugatronOutputHandler>();

//			ExternalHandlers.Add(Handler);
//        }

//        public static void RemoveExternalOutput(IExternalDebugatronOutputHandler Handler)
//        {
//            if (ExternalHandlers == null || ExternalHandlers.Count == 0) return;

//            ExternalHandlers.Remove(Handler);
//        }

//        #endregion
//    }
//}
